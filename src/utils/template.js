"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.template = exports.templateParser = void 0;
const source_map_1 = require("source-map");
// Matches <%= expr %>. This does not support structural JavaScript (for/if/...).
const kInterpolateRe = /<%=([\s\S]+?)%>/g;
// Matches <%# text %>. It's a comment and will be entirely ignored.
const kCommentRe = /<%#([\s\S]+?)%>/g;
// Used to match template delimiters.
// <%- expr %>: HTML escape the value.
// <% ... %>: Structural template code.
const kEscapeRe = /<%-([\s\S]+?)%>/g;
const kEvaluateRe = /<%([\s\S]+?)%>/g;
/** Used to map characters to HTML entities. */
const kHtmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;',
};
// Used to match HTML entities and HTML characters.
const reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');
function _positionFor(content, offset) {
    let line = 1;
    let column = 0;
    for (let i = 0; i < offset - 1; i++) {
        if (content[i] == '\n') {
            line++;
            column = 0;
        }
        else {
            column++;
        }
    }
    return {
        line,
        column,
    };
}
/**
 * Given a source text (and a fileName), returns a TemplateAst.
 */
function templateParser(sourceText, fileName) {
    const children = [];
    // Compile the regexp to match each delimiter.
    const reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];
    const reDelimiters = RegExp(reExpressions.map((x) => x.source).join('|') + '|$', 'g');
    const parsed = sourceText.split(reDelimiters);
    let offset = 0;
    // Optimization that uses the fact that the end of a node is always the beginning of the next
    // node, so we keep the positioning of the nodes in memory.
    let start = _positionFor(sourceText, offset);
    let end;
    const increment = reExpressions.length + 1;
    for (let i = 0; i < parsed.length; i += increment) {
        const [content, escape, comment, interpolate, evaluate] = parsed.slice(i, i + increment);
        if (content) {
            end = _positionFor(sourceText, offset + content.length);
            offset += content.length;
            children.push({ kind: 'content', content, start, end });
            start = end;
        }
        if (escape) {
            end = _positionFor(sourceText, offset + escape.length + 5);
            offset += escape.length + 5;
            children.push({ kind: 'escape', expression: escape, start, end });
            start = end;
        }
        if (comment) {
            end = _positionFor(sourceText, offset + comment.length + 5);
            offset += comment.length + 5;
            children.push({ kind: 'comment', text: comment, start, end });
            start = end;
        }
        if (interpolate) {
            end = _positionFor(sourceText, offset + interpolate.length + 5);
            offset += interpolate.length + 5;
            children.push({
                kind: 'interpolate',
                expression: interpolate,
                start,
                end,
            });
            start = end;
        }
        if (evaluate) {
            end = _positionFor(sourceText, offset + evaluate.length + 5);
            offset += evaluate.length + 5;
            children.push({ kind: 'evaluate', expression: evaluate, start, end });
            start = end;
        }
    }
    return {
        fileName,
        content: sourceText,
        children,
    };
}
exports.templateParser = templateParser;
/**
 * Fastest implementation of the templating algorithm. It only add strings and does not bother
 * with source maps.
 */
function templateFast(ast, options) {
    const module = options && options.module ? 'module.exports.default =' : '';
    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, "\\\\\\'");
    return `
    return ${module} function(obj) {
      obj || (obj = {});
      let __t;
      let __p = '';
      const __escapes = ${JSON.stringify(kHtmlEscapes)};
      const __escapesre = new RegExp('${reHtmlEscape}', 'g');

      const __e = function(s) {
        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';
      };
      with (obj) {
        ${ast.children
        .map((node) => {
        switch (node.kind) {
            case 'content':
                return `__p += ${JSON.stringify(node.content)};`;
            case 'interpolate':
                return `__p += ((__t = (${node.expression})) == null) ? '' : __t;`;
            case 'escape':
                return `__p += __e(${node.expression});`;
            case 'evaluate':
                return node.expression;
        }
    })
        .join('\n')}
      }

      return __p;
    };
  `;
}
/**
 * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...
 */
function templateWithSourceMap(ast, options) {
    const sourceUrl = ast.fileName;
    const module = options && options.module ? 'module.exports.default =' : '';
    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, "\\\\\\'");
    const preamble = new source_map_1.SourceNode(1, 0, sourceUrl, '').add(new source_map_1.SourceNode(1, 0, sourceUrl, [
        `return ${module} function(obj) {\n`,
        '  obj || (obj = {});\n',
        '  let __t;\n',
        '  let __p = "";\n',
        `  const __escapes = ${JSON.stringify(kHtmlEscapes)};\n`,
        `  const __escapesre = new RegExp('${reHtmlEscape}', 'g');\n`,
        `\n`,
        `  const __e = function(s) { `,
        `    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';`,
        `  };\n`,
        `  with (obj) {\n`,
    ]));
    const end = ast.children.length
        ? ast.children[ast.children.length - 1].end
        : { line: 0, column: 0 };
    const nodes = ast.children
        .reduce((chunk, node) => {
        let code = '';
        switch (node.kind) {
            case 'content':
                code = [
                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p'),
                    ...node.content.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\n    + ' + JSON.stringify(line + (i == arr.length - 1 ? '' : '\n')));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\n'),
                ];
                break;
            case 'interpolate':
                code = [
                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = '),
                    ...node.expression.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\n'));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? "" : __t);\n'),
                ];
                break;
            case 'escape':
                code = [
                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e('),
                    ...node.expression.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\n'));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\n'),
                ];
                break;
            case 'evaluate':
                code = [
                    ...node.expression.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\n'));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\n'),
                ];
                break;
        }
        return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));
    }, preamble)
        .add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, ['  };\n', '\n', '  return __p;\n', '}\n']));
    const code = nodes.toStringWithSourceMap({
        file: sourceUrl,
        sourceRoot: (options && options.sourceRoot) || '.',
    });
    // Set the source content in the source map, otherwise the sourceUrl is not enough
    // to find the content.
    code.map.setSourceContent(sourceUrl, ast.content);
    return (code.code +
        '\n//# sourceMappingURL=data:application/json;base64,' +
        Buffer.from(code.map.toString()).toString('base64'));
}
/**
 * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation
 * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js
 * (https://github.com/olado/doT).
 *
 * This version differs from lodash by removing support from ES6 quasi-literals, and making the
 * code slightly simpler to follow. It also does not depend on any third party, which is nice.
 *
 * Finally, it supports SourceMap, if you ever need to debug, which is super nice.
 *
 * @param content The template content.
 * @param options Optional Options. See TemplateOptions for more description.
 * @return {(input: T) => string} A function that accept an input object and returns the content
 *         of the template with the input applied.
 */
function template(content, options) {
    const sourceUrl = (options && options.sourceURL) || 'ejs';
    const ast = templateParser(content, sourceUrl);
    let source;
    // If there's no need for source map support, we revert back to the fast implementation.
    if (options && options.sourceMap) {
        source = templateWithSourceMap(ast, options);
    }
    else {
        source = templateFast(ast, options);
    }
    // We pass a dummy module in case the module option is passed. If `module: true` is passed, we
    // need to only use the source, not the function itself. Otherwise expect a module object to be
    // passed, and we use that one.
    const fn = Function('module', source);
    const module = options && options.module ? (options.module === true ? { exports: {} } : options.module) : null;
    const result = fn(module);
    // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.
    result.source = source;
    return result;
}
exports.template = template;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9hbmd1bGFyX2RldmtpdC9jb3JlL3NyYy91dGlscy90ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOzs7QUFFSCwyQ0FBa0Q7QUFFbEQsaUZBQWlGO0FBQ2pGLE1BQU0sY0FBYyxHQUFHLGtCQUFrQixDQUFDO0FBQzFDLG9FQUFvRTtBQUNwRSxNQUFNLFVBQVUsR0FBRyxrQkFBa0IsQ0FBQztBQUV0QyxxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QyxNQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQztBQUNyQyxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQztBQUV0QywrQ0FBK0M7QUFDL0MsTUFBTSxZQUFZLEdBQStCO0lBQy9DLEdBQUcsRUFBRSxPQUFPO0lBQ1osR0FBRyxFQUFFLE1BQU07SUFDWCxHQUFHLEVBQUUsTUFBTTtJQUNYLEdBQUcsRUFBRSxRQUFRO0lBQ2IsR0FBRyxFQUFFLE9BQU87SUFDWixHQUFHLEVBQUUsT0FBTztDQUNiLENBQUM7QUFFRixtREFBbUQ7QUFDbkQsTUFBTSxlQUFlLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBV25GLFNBQVMsWUFBWSxDQUFDLE9BQWUsRUFBRSxNQUFjO0lBQ25ELElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJ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ICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgeyBQb3NpdGlvbiwgU291cmNlTm9kZSB9IGZyb20gJ3NvdXJjZS1tYXAnO1xuXG4vLyBNYXRjaGVzIDwlPSBleHByICU+LiBUaGlzIGRvZXMgbm90IHN1cHBvcnQgc3RydWN0dXJhbCBKYXZhU2NyaXB0IChmb3IvaWYvLi4uKS5cbmNvbnN0IGtJbnRlcnBvbGF0ZVJlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG4vLyBNYXRjaGVzIDwlIyB0ZXh0ICU+LiBJdCdzIGEgY29tbWVudCBhbmQgd2lsbCBiZSBlbnRpcmVseSBpZ25vcmVkLlxuY29uc3Qga0NvbW1lbnRSZSA9IC88JSMoW1xcc1xcU10rPyklPi9nO1xuXG4vLyBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4vLyA8JS0gZXhwciAlPjogSFRNTCBlc2NhcGUgdGhlIHZhbHVlLlxuLy8gPCUgLi4uICU+OiBTdHJ1Y3R1cmFsIHRlbXBsYXRlIGNvZGUuXG5jb25zdCBrRXNjYXBlUmUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcbmNvbnN0IGtFdmFsdWF0ZVJlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbmNvbnN0IGtIdG1sRXNjYXBlczogeyBbY2hhcjogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICdgJzogJyYjOTY7Jyxcbn07XG5cbi8vIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLlxuY29uc3QgcmVVbmVzY2FwZWRIdG1sID0gbmV3IFJlZ0V4cChgWyR7T2JqZWN0LmtleXMoa0h0bWxFc2NhcGVzKS5qb2luKCcnKX1dYCwgJ2cnKTtcblxuLy8gT3B0aW9ucyB0byBwYXNzIHRvIHRlbXBsYXRlLlxuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZU9wdGlvbnMge1xuICBzb3VyY2VVUkw/OiBzdHJpbmc7XG4gIHNvdXJjZU1hcD86IGJvb2xlYW47XG4gIG1vZHVsZT86IGJvb2xlYW4gfCB7IGV4cG9ydHM6IHt9IH07XG4gIHNvdXJjZVJvb3Q/OiBzdHJpbmc7XG4gIGZpbGVOYW1lPzogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBfcG9zaXRpb25Gb3IoY29udGVudDogc3RyaW5nLCBvZmZzZXQ6IG51bWJlcik6IFBvc2l0aW9uIHtcbiAgbGV0IGxpbmUgPSAxO1xuICBsZXQgY29sdW1uID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzZXQgLSAxOyBpKyspIHtcbiAgICBpZiAoY29udGVudFtpXSA9PSAnXFxuJykge1xuICAgICAgbGluZSsrO1xuICAgICAgY29sdW1uID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sdW1uKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBBU1QgZm9yIHRlbXBsYXRlcy4gVGhlcmUncyBvbmx5IG9uZSBsZXZlbCBvZiBBU1Qgbm9kZXMsIGJ1dCBpdCdzIHN0aWxsIHVzZWZ1bFxuICogdG8gaGF2ZSB0aGUgaW5mb3JtYXRpb24geW91J3JlIGxvb2tpbmcgZm9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlQXN0IHtcbiAgZmlsZU5hbWU6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBjaGlsZHJlbjogVGVtcGxhdGVBc3ROb2RlW107XG59XG5cbi8qKlxuICogVGhlIGJhc2UsIHdoaWNoIGNvbnRhaW5zIHBvc2l0aW9ucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZUFzdEJhc2Uge1xuICBzdGFydDogUG9zaXRpb247XG4gIGVuZDogUG9zaXRpb247XG59XG5cbi8qKlxuICogQSBzdGF0aWMgY29udGVudCBub2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlQXN0Q29udGVudCBleHRlbmRzIFRlbXBsYXRlQXN0QmFzZSB7XG4gIGtpbmQ6ICdjb250ZW50JztcbiAgY29udGVudDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY29tbWVudCBub2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlQXN0Q29tbWVudCBleHRlbmRzIFRlbXBsYXRlQXN0QmFzZSB7XG4gIGtpbmQ6ICdjb21tZW50JztcbiAgdGV4dDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFuIGV2YWx1YXRlIG5vZGUsIHdoaWNoIGlzIHRoZSBjb2RlIGJldHdlZW4gYDwlIC4uLiAlPmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVBc3RFdmFsdWF0ZSBleHRlbmRzIFRlbXBsYXRlQXN0QmFzZSB7XG4gIGtpbmQ6ICdldmFsdWF0ZSc7XG4gIGV4cHJlc3Npb246IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbiBlc2NhcGUgbm9kZSwgd2hpY2ggaXMgdGhlIGNvZGUgYmV0d2VlbiBgPCUtIC4uLiAlPmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVBc3RFc2NhcGUgZXh0ZW5kcyBUZW1wbGF0ZUFzdEJhc2Uge1xuICBraW5kOiAnZXNjYXBlJztcbiAgZXhwcmVzc2lvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFuIGludGVycG9sYXRpb24gbm9kZSwgd2hpY2ggaXMgdGhlIGNvZGUgYmV0d2VlbiBgPCU9IC4uLiAlPmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVBc3RJbnRlcnBvbGF0ZSBleHRlbmRzIFRlbXBsYXRlQXN0QmFzZSB7XG4gIGtpbmQ6ICdpbnRlcnBvbGF0ZSc7XG4gIGV4cHJlc3Npb246IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgVGVtcGxhdGVBc3ROb2RlID1cbiAgfCBUZW1wbGF0ZUFzdENvbnRlbnRcbiAgfCBUZW1wbGF0ZUFzdEV2YWx1YXRlXG4gIHwgVGVtcGxhdGVBc3RDb21tZW50XG4gIHwgVGVtcGxhdGVBc3RFc2NhcGVcbiAgfCBUZW1wbGF0ZUFzdEludGVycG9sYXRlO1xuXG4vKipcbiAqIEdpdmVuIGEgc291cmNlIHRleHQgKGFuZCBhIGZpbGVOYW1lKSwgcmV0dXJucyBhIFRlbXBsYXRlQXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVQYXJzZXIoc291cmNlVGV4dDogc3RyaW5nLCBmaWxlTmFtZTogc3RyaW5nKTogVGVtcGxhdGVBc3Qge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgY29uc3QgcmVFeHByZXNzaW9ucyA9IFtrRXNjYXBlUmUsIGtDb21tZW50UmUsIGtJbnRlcnBvbGF0ZVJlLCBrRXZhbHVhdGVSZV07XG4gIGNvbnN0IHJlRGVsaW1pdGVycyA9IFJlZ0V4cChyZUV4cHJlc3Npb25zLm1hcCgoeCkgPT4geC5zb3VyY2UpLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgY29uc3QgcGFyc2VkID0gc291cmNlVGV4dC5zcGxpdChyZURlbGltaXRlcnMpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgLy8gT3B0aW1pemF0aW9uIHRoYXQgdXNlcyB0aGUgZmFjdCB0aGF0IHRoZSBlbmQgb2YgYSBub2RlIGlzIGFsd2F5cyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0XG4gIC8vIG5vZGUsIHNvIHdlIGtlZXAgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBub2RlcyBpbiBtZW1vcnkuXG4gIGxldCBzdGFydCA9IF9wb3NpdGlvbkZvcihzb3VyY2VUZXh0LCBvZmZzZXQpO1xuICBsZXQgZW5kOiBQb3NpdGlvbiB8IG51bGw7XG5cbiAgY29uc3QgaW5jcmVtZW50ID0gcmVFeHByZXNzaW9ucy5sZW5ndGggKyAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgY29uc3QgW2NvbnRlbnQsIGVzY2FwZSwgY29tbWVudCwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlXSA9IHBhcnNlZC5zbGljZShpLCBpICsgaW5jcmVtZW50KTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgZW5kID0gX3Bvc2l0aW9uRm9yKHNvdXJjZVRleHQsIG9mZnNldCArIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgIG9mZnNldCArPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgIGNoaWxkcmVuLnB1c2goeyBraW5kOiAnY29udGVudCcsIGNvbnRlbnQsIHN0YXJ0LCBlbmQgfSBhcyBUZW1wbGF0ZUFzdENvbnRlbnQpO1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgIGVuZCA9IF9wb3NpdGlvbkZvcihzb3VyY2VUZXh0LCBvZmZzZXQgKyBlc2NhcGUubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gZXNjYXBlLmxlbmd0aCArIDU7XG4gICAgICBjaGlsZHJlbi5wdXNoKHsga2luZDogJ2VzY2FwZScsIGV4cHJlc3Npb246IGVzY2FwZSwgc3RhcnQsIGVuZCB9IGFzIFRlbXBsYXRlQXN0RXNjYXBlKTtcbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgZW5kID0gX3Bvc2l0aW9uRm9yKHNvdXJjZVRleHQsIG9mZnNldCArIGNvbW1lbnQubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gY29tbWVudC5sZW5ndGggKyA1O1xuICAgICAgY2hpbGRyZW4ucHVzaCh7IGtpbmQ6ICdjb21tZW50JywgdGV4dDogY29tbWVudCwgc3RhcnQsIGVuZCB9IGFzIFRlbXBsYXRlQXN0Q29tbWVudCk7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBlbmQgPSBfcG9zaXRpb25Gb3Ioc291cmNlVGV4dCwgb2Zmc2V0ICsgaW50ZXJwb2xhdGUubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gaW50ZXJwb2xhdGUubGVuZ3RoICsgNTtcbiAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICBraW5kOiAnaW50ZXJwb2xhdGUnLFxuICAgICAgICBleHByZXNzaW9uOiBpbnRlcnBvbGF0ZSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgIH0gYXMgVGVtcGxhdGVBc3RJbnRlcnBvbGF0ZSk7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlKSB7XG4gICAgICBlbmQgPSBfcG9zaXRpb25Gb3Ioc291cmNlVGV4dCwgb2Zmc2V0ICsgZXZhbHVhdGUubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gZXZhbHVhdGUubGVuZ3RoICsgNTtcbiAgICAgIGNoaWxkcmVuLnB1c2goeyBraW5kOiAnZXZhbHVhdGUnLCBleHByZXNzaW9uOiBldmFsdWF0ZSwgc3RhcnQsIGVuZCB9IGFzIFRlbXBsYXRlQXN0RXZhbHVhdGUpO1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlTmFtZSxcbiAgICBjb250ZW50OiBzb3VyY2VUZXh0LFxuICAgIGNoaWxkcmVuLFxuICB9O1xufVxuXG4vKipcbiAqIEZhc3Rlc3QgaW1wbGVtZW50YXRpb24gb2YgdGhlIHRlbXBsYXRpbmcgYWxnb3JpdGhtLiBJdCBvbmx5IGFkZCBzdHJpbmdzIGFuZCBkb2VzIG5vdCBib3RoZXJcbiAqIHdpdGggc291cmNlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlRmFzdChhc3Q6IFRlbXBsYXRlQXN0LCBvcHRpb25zPzogVGVtcGxhdGVPcHRpb25zKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kdWxlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1vZHVsZSA/ICdtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0nIDogJyc7XG4gIGNvbnN0IHJlSHRtbEVzY2FwZSA9IHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UucmVwbGFjZSgvWyddL2csIFwiXFxcXFxcXFxcXFxcJ1wiKTtcblxuICByZXR1cm4gYFxuICAgIHJldHVybiAke21vZHVsZX0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBvYmogfHwgKG9iaiA9IHt9KTtcbiAgICAgIGxldCBfX3Q7XG4gICAgICBsZXQgX19wID0gJyc7XG4gICAgICBjb25zdCBfX2VzY2FwZXMgPSAke0pTT04uc3RyaW5naWZ5KGtIdG1sRXNjYXBlcyl9O1xuICAgICAgY29uc3QgX19lc2NhcGVzcmUgPSBuZXcgUmVnRXhwKCcke3JlSHRtbEVzY2FwZX0nLCAnZycpO1xuXG4gICAgICBjb25zdCBfX2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzID8gcy5yZXBsYWNlKF9fZXNjYXBlc3JlLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIF9fZXNjYXBlc1trZXldOyB9KSA6ICcnO1xuICAgICAgfTtcbiAgICAgIHdpdGggKG9iaikge1xuICAgICAgICAke2FzdC5jaGlsZHJlblxuICAgICAgICAgIC5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgX19wICs9ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX07YDtcbiAgICAgICAgICAgICAgY2FzZSAnaW50ZXJwb2xhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgX19wICs9ICgoX190ID0gKCR7bm9kZS5leHByZXNzaW9ufSkpID09IG51bGwpID8gJycgOiBfX3Q7YDtcbiAgICAgICAgICAgICAgY2FzZSAnZXNjYXBlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYF9fcCArPSBfX2UoJHtub2RlLmV4cHJlc3Npb259KTtgO1xuICAgICAgICAgICAgICBjYXNlICdldmFsdWF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5qb2luKCdcXG4nKX1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fcDtcbiAgICB9O1xuICBgO1xufVxuXG4vKipcbiAqIFRlbXBsYXRpbmcgYWxnb3JpdGhtIHdpdGggc291cmNlIG1hcCBzdXBwb3J0LiBUaGUgbWFwIGlzIG91dHB1dHRlZCBhcyAvLyMgc291cmNlTWFwVXJsPS4uLlxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZVdpdGhTb3VyY2VNYXAoYXN0OiBUZW1wbGF0ZUFzdCwgb3B0aW9ucz86IFRlbXBsYXRlT3B0aW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHNvdXJjZVVybCA9IGFzdC5maWxlTmFtZTtcbiAgY29uc3QgbW9kdWxlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1vZHVsZSA/ICdtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0nIDogJyc7XG4gIGNvbnN0IHJlSHRtbEVzY2FwZSA9IHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UucmVwbGFjZSgvWyddL2csIFwiXFxcXFxcXFxcXFxcJ1wiKTtcblxuICBjb25zdCBwcmVhbWJsZSA9IG5ldyBTb3VyY2VOb2RlKDEsIDAsIHNvdXJjZVVybCwgJycpLmFkZChcbiAgICBuZXcgU291cmNlTm9kZSgxLCAwLCBzb3VyY2VVcmwsIFtcbiAgICAgIGByZXR1cm4gJHttb2R1bGV9IGZ1bmN0aW9uKG9iaikge1xcbmAsXG4gICAgICAnICBvYmogfHwgKG9iaiA9IHt9KTtcXG4nLFxuICAgICAgJyAgbGV0IF9fdDtcXG4nLFxuICAgICAgJyAgbGV0IF9fcCA9IFwiXCI7XFxuJyxcbiAgICAgIGAgIGNvbnN0IF9fZXNjYXBlcyA9ICR7SlNPTi5zdHJpbmdpZnkoa0h0bWxFc2NhcGVzKX07XFxuYCxcbiAgICAgIGAgIGNvbnN0IF9fZXNjYXBlc3JlID0gbmV3IFJlZ0V4cCgnJHtyZUh0bWxFc2NhcGV9JywgJ2cnKTtcXG5gLFxuICAgICAgYFxcbmAsXG4gICAgICBgICBjb25zdCBfX2UgPSBmdW5jdGlvbihzKSB7IGAsXG4gICAgICBgICAgIHJldHVybiBzID8gcy5yZXBsYWNlKF9fZXNjYXBlc3JlLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIF9fZXNjYXBlc1trZXldOyB9KSA6ICcnO2AsXG4gICAgICBgICB9O1xcbmAsXG4gICAgICBgICB3aXRoIChvYmopIHtcXG5gLFxuICAgIF0pLFxuICApO1xuXG4gIGNvbnN0IGVuZCA9IGFzdC5jaGlsZHJlbi5sZW5ndGhcbiAgICA/IGFzdC5jaGlsZHJlblthc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uZW5kXG4gICAgOiB7IGxpbmU6IDAsIGNvbHVtbjogMCB9O1xuICBjb25zdCBub2RlcyA9IGFzdC5jaGlsZHJlblxuICAgIC5yZWR1Y2UoKGNodW5rLCBub2RlKSA9PiB7XG4gICAgICBsZXQgY29kZTogc3RyaW5nIHwgU291cmNlTm9kZSB8IChTb3VyY2VOb2RlIHwgc3RyaW5nKVtdID0gJyc7XG4gICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICBjYXNlICdjb250ZW50JzpcbiAgICAgICAgICBjb2RlID0gW1xuICAgICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5zdGFydC5saW5lLCBub2RlLnN0YXJ0LmNvbHVtbiwgc291cmNlVXJsLCAnX19wID0gX19wJyksXG4gICAgICAgICAgICAuLi5ub2RlLmNvbnRlbnQuc3BsaXQoJ1xcbicpLm1hcCgobGluZSwgaSwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LmxpbmUgKyBpLFxuICAgICAgICAgICAgICAgIGkgPT0gMCA/IG5vZGUuc3RhcnQuY29sdW1uIDogMCxcbiAgICAgICAgICAgICAgICBzb3VyY2VVcmwsXG4gICAgICAgICAgICAgICAgJ1xcbiAgICArICcgKyBKU09OLnN0cmluZ2lmeShsaW5lICsgKGkgPT0gYXJyLmxlbmd0aCAtIDEgPyAnJyA6ICdcXG4nKSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldyBTb3VyY2VOb2RlKG5vZGUuZW5kLmxpbmUsIG5vZGUuZW5kLmNvbHVtbiwgc291cmNlVXJsLCAnO1xcbicpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ludGVycG9sYXRlJzpcbiAgICAgICAgICBjb2RlID0gW1xuICAgICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5zdGFydC5saW5lLCBub2RlLnN0YXJ0LmNvbHVtbiwgc291cmNlVXJsLCAnX19wICs9ICgoX190ID0gJyksXG4gICAgICAgICAgICAuLi5ub2RlLmV4cHJlc3Npb24uc3BsaXQoJ1xcbicpLm1hcCgobGluZSwgaSwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LmxpbmUgKyBpLFxuICAgICAgICAgICAgICAgIGkgPT0gMCA/IG5vZGUuc3RhcnQuY29sdW1uIDogMCxcbiAgICAgICAgICAgICAgICBzb3VyY2VVcmwsXG4gICAgICAgICAgICAgICAgbGluZSArIChpID09IGFyci5sZW5ndGggLSAxID8gJycgOiAnXFxuJyksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldyBTb3VyY2VOb2RlKG5vZGUuZW5kLmxpbmUsIG5vZGUuZW5kLmNvbHVtbiwgc291cmNlVXJsLCAnKSA9PSBudWxsID8gXCJcIiA6IF9fdCk7XFxuJyksXG4gICAgICAgICAgXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZXNjYXBlJzpcbiAgICAgICAgICBjb2RlID0gW1xuICAgICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5zdGFydC5saW5lLCBub2RlLnN0YXJ0LmNvbHVtbiwgc291cmNlVXJsLCAnX19wICs9IF9fZSgnKSxcbiAgICAgICAgICAgIC4uLm5vZGUuZXhwcmVzc2lvbi5zcGxpdCgnXFxuJykubWFwKChsaW5lLCBpLCBhcnIpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKFxuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQubGluZSArIGksXG4gICAgICAgICAgICAgICAgaSA9PSAwID8gbm9kZS5zdGFydC5jb2x1bW4gOiAwLFxuICAgICAgICAgICAgICAgIHNvdXJjZVVybCxcbiAgICAgICAgICAgICAgICBsaW5lICsgKGkgPT0gYXJyLmxlbmd0aCAtIDEgPyAnJyA6ICdcXG4nKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5lbmQubGluZSwgbm9kZS5lbmQuY29sdW1uLCBzb3VyY2VVcmwsICcpO1xcbicpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2V2YWx1YXRlJzpcbiAgICAgICAgICBjb2RlID0gW1xuICAgICAgICAgICAgLi4ubm9kZS5leHByZXNzaW9uLnNwbGl0KCdcXG4nKS5tYXAoKGxpbmUsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUoXG4gICAgICAgICAgICAgICAgbm9kZS5zdGFydC5saW5lICsgaSxcbiAgICAgICAgICAgICAgICBpID09IDAgPyBub2RlLnN0YXJ0LmNvbHVtbiA6IDAsXG4gICAgICAgICAgICAgICAgc291cmNlVXJsLFxuICAgICAgICAgICAgICAgIGxpbmUgKyAoaSA9PSBhcnIubGVuZ3RoIC0gMSA/ICcnIDogJ1xcbicpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXcgU291cmNlTm9kZShub2RlLmVuZC5saW5lLCBub2RlLmVuZC5jb2x1bW4sIHNvdXJjZVVybCwgJ1xcbicpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaHVuay5hZGQobmV3IFNvdXJjZU5vZGUobm9kZS5zdGFydC5saW5lLCBub2RlLnN0YXJ0LmNvbHVtbiwgc291cmNlVXJsLCBjb2RlKSk7XG4gICAgfSwgcHJlYW1ibGUpXG4gICAgLmFkZChcbiAgICAgIG5ldyBTb3VyY2VOb2RlKGVuZC5saW5lLCBlbmQuY29sdW1uLCBzb3VyY2VVcmwsIFsnICB9O1xcbicsICdcXG4nLCAnICByZXR1cm4gX19wO1xcbicsICd9XFxuJ10pLFxuICAgICk7XG5cbiAgY29uc3QgY29kZSA9IG5vZGVzLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XG4gICAgZmlsZTogc291cmNlVXJsLFxuICAgIHNvdXJjZVJvb3Q6IChvcHRpb25zICYmIG9wdGlvbnMuc291cmNlUm9vdCkgfHwgJy4nLFxuICB9KTtcblxuICAvLyBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGluIHRoZSBzb3VyY2UgbWFwLCBvdGhlcndpc2UgdGhlIHNvdXJjZVVybCBpcyBub3QgZW5vdWdoXG4gIC8vIHRvIGZpbmQgdGhlIGNvbnRlbnQuXG4gIGNvZGUubWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlVXJsLCBhc3QuY29udGVudCk7XG5cbiAgcmV0dXJuIChcbiAgICBjb2RlLmNvZGUgK1xuICAgICdcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgK1xuICAgIEJ1ZmZlci5mcm9tKGNvZGUubWFwLnRvU3RyaW5nKCkpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICApO1xufVxuXG4vKipcbiAqIEFuIGVxdWl2YWxlbnQgb2YgRUpTIHRlbXBsYXRlcywgd2hpY2ggaXMgYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICogKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKSBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gKlxuICogVGhpcyB2ZXJzaW9uIGRpZmZlcnMgZnJvbSBsb2Rhc2ggYnkgcmVtb3Zpbmcgc3VwcG9ydCBmcm9tIEVTNiBxdWFzaS1saXRlcmFscywgYW5kIG1ha2luZyB0aGVcbiAqIGNvZGUgc2xpZ2h0bHkgc2ltcGxlciB0byBmb2xsb3cuIEl0IGFsc28gZG9lcyBub3QgZGVwZW5kIG9uIGFueSB0aGlyZCBwYXJ0eSwgd2hpY2ggaXMgbmljZS5cbiAqXG4gKiBGaW5hbGx5LCBpdCBzdXBwb3J0cyBTb3VyY2VNYXAsIGlmIHlvdSBldmVyIG5lZWQgdG8gZGVidWcsIHdoaWNoIGlzIHN1cGVyIG5pY2UuXG4gKlxuICogQHBhcmFtIGNvbnRlbnQgVGhlIHRlbXBsYXRlIGNvbnRlbnQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBPcHRpb25zLiBTZWUgVGVtcGxhdGVPcHRpb25zIGZvciBtb3JlIGRlc2NyaXB0aW9uLlxuICogQHJldHVybiB7KGlucHV0OiBUKSA9PiBzdHJpbmd9IEEgZnVuY3Rpb24gdGhhdCBhY2NlcHQgYW4gaW5wdXQgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBjb250ZW50XG4gKiAgICAgICAgIG9mIHRoZSB0ZW1wbGF0ZSB3aXRoIHRoZSBpbnB1dCBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGU8VD4oY29udGVudDogc3RyaW5nLCBvcHRpb25zPzogVGVtcGxhdGVPcHRpb25zKTogKGlucHV0OiBUKSA9PiBzdHJpbmcge1xuICBjb25zdCBzb3VyY2VVcmwgPSAob3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZVVSTCkgfHwgJ2Vqcyc7XG4gIGNvbnN0IGFzdCA9IHRlbXBsYXRlUGFyc2VyKGNvbnRlbnQsIHNvdXJjZVVybCk7XG5cbiAgbGV0IHNvdXJjZTogc3RyaW5nO1xuICAvLyBJZiB0aGVyZSdzIG5vIG5lZWQgZm9yIHNvdXJjZSBtYXAgc3VwcG9ydCwgd2UgcmV2ZXJ0IGJhY2sgdG8gdGhlIGZhc3QgaW1wbGVtZW50YXRpb24uXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc291cmNlTWFwKSB7XG4gICAgc291cmNlID0gdGVtcGxhdGVXaXRoU291cmNlTWFwKGFzdCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gdGVtcGxhdGVGYXN0KGFzdCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBXZSBwYXNzIGEgZHVtbXkgbW9kdWxlIGluIGNhc2UgdGhlIG1vZHVsZSBvcHRpb24gaXMgcGFzc2VkLiBJZiBgbW9kdWxlOiB0cnVlYCBpcyBwYXNzZWQsIHdlXG4gIC8vIG5lZWQgdG8gb25seSB1c2UgdGhlIHNvdXJjZSwgbm90IHRoZSBmdW5jdGlvbiBpdHNlbGYuIE90aGVyd2lzZSBleHBlY3QgYSBtb2R1bGUgb2JqZWN0IHRvIGJlXG4gIC8vIHBhc3NlZCwgYW5kIHdlIHVzZSB0aGF0IG9uZS5cbiAgY29uc3QgZm4gPSBGdW5jdGlvbignbW9kdWxlJywgc291cmNlKTtcbiAgY29uc3QgbW9kdWxlID1cbiAgICBvcHRpb25zICYmIG9wdGlvbnMubW9kdWxlID8gKG9wdGlvbnMubW9kdWxlID09PSB0cnVlID8geyBleHBvcnRzOiB7fSB9IDogb3B0aW9ucy5tb2R1bGUpIDogbnVsbDtcbiAgY29uc3QgcmVzdWx0ID0gZm4obW9kdWxlKTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIl19