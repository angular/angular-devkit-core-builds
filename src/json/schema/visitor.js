"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const from_1 = require("rxjs/observable/from");
const of_1 = require("rxjs/observable/of");
const operators_1 = require("rxjs/operators");
const observable_1 = require("rxjs/symbol/observable");
function buildJsonPointer(fragments) {
    return ('/' + fragments.map(f => {
        return f.replace(/~/g, '~0')
            .replace(/\//g, '~1');
    }).join('/'));
}
exports.buildJsonPointer = buildJsonPointer;
function joinJsonPointer(root, ...others) {
    if (root == '/') {
        return buildJsonPointer(others);
    }
    return (root + buildJsonPointer(others));
}
exports.joinJsonPointer = joinJsonPointer;
function parseJsonPointer(pointer) {
    if (pointer === '') {
        return [];
    }
    if (pointer.charAt(0) !== '/') {
        throw new Error('Relative pointer: ' + pointer);
    }
    return pointer.substring(1).split(/\//).map(str => str.replace(/~1/g, '/').replace(/~0/g, '~'));
}
exports.parseJsonPointer = parseJsonPointer;
function _getObjectSubSchema(schema, key) {
    if (typeof schema !== 'object' || schema === null) {
        return undefined;
    }
    // Is it an object schema?
    if (typeof schema.properties == 'object' || schema.type == 'object') {
        if (typeof schema.properties == 'object'
            && typeof schema.properties[key] == 'object') {
            return schema.properties[key];
        }
        if (typeof schema.additionalProperties == 'object') {
            return schema.additionalProperties;
        }
        return undefined;
    }
    // Is it an array schema?
    if (typeof schema.items == 'object' || schema.type == 'array') {
        return typeof schema.items == 'object' ? schema.items : undefined;
    }
    return undefined;
}
function _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, // tslint:disable-line:no-any
    root) {
    if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {
        if (refResolver) {
            const resolved = refResolver(schema['$ref'], context);
            schema = resolved.schema;
            context = resolved.context;
        }
    }
    const value = visitor(json, ptr, schema, root);
    return ((typeof value == 'object' && value != null && observable_1.observable in value)
        ? value
        : of_1.of(value)).pipe(operators_1.concatMap((value) => {
        if (Array.isArray(value)) {
            return from_1.from(value).pipe(operators_1.mergeMap((item, i) => {
                return _visitJsonRecursive(item, visitor, joinJsonPointer(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe(operators_1.tap(x => value[i] = x));
            }), operators_1.ignoreElements(), operators_1.concat(of_1.of(value)));
        }
        else if (typeof value == 'object' && value !== null) {
            return from_1.from(Object.getOwnPropertyNames(value)).pipe(operators_1.mergeMap(key => {
                return _visitJsonRecursive(value[key], visitor, joinJsonPointer(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe(operators_1.tap(x => value[key] = x));
            }), operators_1.ignoreElements(), operators_1.concat(of_1.of(value)));
        }
        else {
            return of_1.of(value);
        }
    }));
}
/**
 * Visit all the properties in a JSON object, allowing to transform them. It supports calling
 * properties synchronously or asynchronously (through Observables).
 * The original object can be mutated or replaced entirely. In case where it's replaced, the new
 * value is returned. When it's mutated though the original object will be changed.
 *
 * Please note it is possible to have an infinite loop here (which will result in a stack overflow)
 * if you return 2 objects that references each others (or the same object all the time).
 *
 * @param {JsonValue} json The Json value to visit.
 * @param {JsonVisitor} visitor A function that will be called on every items.
 * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).
 * @param refResolver a function to resolve references in the schema.
 * @returns {Observable< | undefined>} The observable of the new root, if the root changed.
 */
function visitJson(json, visitor, schema, refResolver, context) {
    return _visitJsonRecursive(json, visitor, buildJsonPointer([]), schema, refResolver, context);
}
exports.visitJson = visitJson;
function visitJsonSchema(schema, visitor) {
    const keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
    };
    const propsKeywords = {
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true,
    };
    function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {
        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
            visitor(schema, jsonPtr, parentSchema, keyIndex);
            for (const key of Object.keys(schema)) {
                const sch = schema[key];
                if (Array.isArray(sch)) {
                    if (key == 'items') {
                        for (let i = 0; i < sch.length; i++) {
                            _traverse(sch[i], joinJsonPointer(jsonPtr, key, '' + i), rootSchema, schema, '' + i);
                        }
                    }
                }
                else if (key in propsKeywords) {
                    if (sch && typeof sch == 'object') {
                        for (const prop of Object.keys(sch)) {
                            _traverse(sch[prop], joinJsonPointer(jsonPtr, key, prop), rootSchema, schema, prop);
                        }
                    }
                }
                else if (key in keywords) {
                    _traverse(sch, joinJsonPointer(jsonPtr, key), rootSchema, schema, key);
                }
            }
        }
    }
    _traverse(schema, buildJsonPointer([]), schema);
}
exports.visitJsonSchema = visitJsonSchema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlzaXRvci5qcyIsInNvdXJjZVJvb3QiOiIuLyIsInNvdXJjZXMiOlsicGFja2FnZXMvYW5ndWxhcl9kZXZraXQvY29yZS9zcmMvanNvbi9zY2hlbWEvdmlzaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQVFBLCtDQUE0QztBQUM1QywyQ0FBd0Q7QUFDeEQsOENBQWtGO0FBQ2xGLHVEQUFvRDtBQStCcEQsMEJBQWlDLFNBQW1CO0lBQ2xELE1BQU0sQ0FBQyxDQUNMLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3RCLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7YUFDbkIsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNoQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQ0UsQ0FBQztBQUNuQixDQUFDO0FBUEQsNENBT0M7QUFDRCx5QkFBZ0MsSUFBaUIsRUFBRSxHQUFHLE1BQWdCO0lBQ3BFLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2hCLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsTUFBTSxDQUFDLENBQUMsSUFBSSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFnQixDQUFDO0FBQzFELENBQUM7QUFORCwwQ0FNQztBQUNELDBCQUFpQyxPQUFvQjtJQUNuRCxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFBQyxDQUFDO0lBQ2xDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztRQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsT0FBTyxD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RSxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQ25DLFVBQVUsRUFDVixNQUFNLEVBQ04sSUFBSSxDQUNMLENBQUM7d0JBQ0osQ0FBQztvQkFDSCxDQUFDO2dCQUNILENBQUM7Z0JBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDO29CQUMzQixTQUFTLENBQUMsR0FBaUIsRUFBRSxlQUFlLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZGLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRCxTQUFTLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUE3REQsMENBNkRDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0IHsgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IGNvbmNhdCwgY29uY2F0TWFwLCBpZ25vcmVFbGVtZW50cywgbWVyZ2VNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tICdyeGpzL3N5bWJvbC9vYnNlcnZhYmxlJztcbmltcG9ydCB7IEpzb25BcnJheSwgSnNvbk9iamVjdCwgSnNvblZhbHVlIH0gZnJvbSAnLi4nO1xuXG5leHBvcnQgdHlwZSBKc29uUG9pbnRlciA9IHN0cmluZyAmIHtcbiAgX19QUklWQVRFX0RFVktJVF9KU09OX1BPSU5URVI6IHZvaWQ7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEpzb25TY2hlbWFWaXNpdG9yIHtcbiAgKFxuICAgIGN1cnJlbnQ6IEpzb25PYmplY3QgfCBKc29uQXJyYXksXG4gICAgcG9pbnRlcjogSnNvblBvaW50ZXIsXG4gICAgcGFyZW50U2NoZW1hPzogSnNvbk9iamVjdCB8IEpzb25BcnJheSxcbiAgICBpbmRleD86IHN0cmluZyxcbiAgKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKc29uVmlzaXRvciB7XG4gIChcbiAgICB2YWx1ZTogSnNvblZhbHVlIHwgdW5kZWZpbmVkLFxuICAgIHBvaW50ZXI6IEpzb25Qb2ludGVyLFxuICAgIHNjaGVtYT86IEpzb25PYmplY3QsXG4gICAgcm9vdD86IEpzb25PYmplY3QgfCBKc29uQXJyYXksXG4gICk6IE9ic2VydmFibGU8SnNvblZhbHVlIHwgdW5kZWZpbmVkPiB8IEpzb25WYWx1ZSB8IHVuZGVmaW5lZDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZmVyZW5jZVJlc29sdmVyPENvbnRleHRUPiB7XG4gIChyZWY6IHN0cmluZywgY29udGV4dD86IENvbnRleHRUKTogeyBjb250ZXh0PzogQ29udGV4dFQsIHNjaGVtYT86IEpzb25PYmplY3QgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRKc29uUG9pbnRlcihmcmFnbWVudHM6IHN0cmluZ1tdKTogSnNvblBvaW50ZXIge1xuICByZXR1cm4gKFxuICAgICcvJyArIGZyYWdtZW50cy5tYXAoZiA9PiB7XG4gICAgICByZXR1cm4gZi5yZXBsYWNlKC9+L2csICd+MCcpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG4gICAgfSkuam9pbignLycpXG4gICkgYXMgSnNvblBvaW50ZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gam9pbkpzb25Qb2ludGVyKHJvb3Q6IEpzb25Qb2ludGVyLCAuLi5vdGhlcnM6IHN0cmluZ1tdKTogSnNvblBvaW50ZXIge1xuICBpZiAocm9vdCA9PSAnLycpIHtcbiAgICByZXR1cm4gYnVpbGRKc29uUG9pbnRlcihvdGhlcnMpO1xuICB9XG5cbiAgcmV0dXJuIChyb290ICsgYnVpbGRKc29uUG9pbnRlcihvdGhlcnMpKSBhcyBKc29uUG9pbnRlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUpzb25Qb2ludGVyKHBvaW50ZXI6IEpzb25Qb2ludGVyKTogc3RyaW5nW10ge1xuICBpZiAocG9pbnRlciA9PT0gJycpIHsgcmV0dXJuIFtdOyB9XG4gIGlmIChwb2ludGVyLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHRocm93IG5ldyBFcnJvcignUmVsYXRpdmUgcG9pbnRlcjogJyArIHBvaW50ZXIpOyB9XG5cbiAgcmV0dXJuIHBvaW50ZXIuc3Vic3RyaW5nKDEpLnNwbGl0KC9cXC8vKS5tYXAoc3RyID0+IHN0ci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+JykpO1xufVxuXG5mdW5jdGlvbiBfZ2V0T2JqZWN0U3ViU2NoZW1hKFxuICBzY2hlbWE6IEpzb25PYmplY3QgfCB1bmRlZmluZWQsXG4gIGtleTogc3RyaW5nLFxuKTogSnNvbk9iamVjdCB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JyB8fCBzY2hlbWEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gSXMgaXQgYW4gb2JqZWN0IHNjaGVtYT9cbiAgaWYgKHR5cGVvZiBzY2hlbWEucHJvcGVydGllcyA9PSAnb2JqZWN0JyB8fCBzY2hlbWEudHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXMgPT0gJ29iamVjdCdcbiAgICAgICAgJiYgdHlwZW9mIChzY2hlbWEucHJvcGVydGllcyBhcyBKc29uT2JqZWN0KVtrZXldID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gKHNjaGVtYS5wcm9wZXJ0aWVzIGFzIEpzb25PYmplY3QpW2tleV0gYXMgSnNvbk9iamVjdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgYXMgSnNvbk9iamVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gSXMgaXQgYW4gYXJyYXkgc2NoZW1hP1xuICBpZiAodHlwZW9mIHNjaGVtYS5pdGVtcyA9PSAnb2JqZWN0JyB8fCBzY2hlbWEudHlwZSA9PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuaXRlbXMgPT0gJ29iamVjdCcgPyAoc2NoZW1hLml0ZW1zIGFzIEpzb25PYmplY3QpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX3Zpc2l0SnNvblJlY3Vyc2l2ZTxDb250ZXh0VD4oXG4gIGpzb246IEpzb25WYWx1ZSxcbiAgdmlzaXRvcjogSnNvblZpc2l0b3IsXG4gIHB0cjogSnNvblBvaW50ZXIsXG4gIHNjaGVtYT86IEpzb25PYmplY3QsXG4gIHJlZlJlc29sdmVyPzogUmVmZXJlbmNlUmVzb2x2ZXI8Q29udGV4dFQ+LFxuICBjb250ZXh0PzogQ29udGV4dFQsICAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWFueVxuICByb290PzogSnNvbk9iamVjdCB8IEpzb25BcnJheSxcbik6IE9ic2VydmFibGU8SnNvblZhbHVlIHwgdW5kZWZpbmVkPiB7XG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hLmhhc093blByb3BlcnR5KCckcmVmJykgJiYgdHlwZW9mIHNjaGVtYVsnJHJlZiddID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHJlZlJlc29sdmVyKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlZlJlc29sdmVyKHNjaGVtYVsnJHJlZiddIGFzIHN0cmluZywgY29udGV4dCk7XG4gICAgICBzY2hlbWEgPSByZXNvbHZlZC5zY2hlbWE7XG4gICAgICBjb250ZXh0ID0gcmVzb2x2ZWQuY29udGV4dDtcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHZpc2l0b3IoanNvbiwgcHRyLCBzY2hlbWEsIHJvb3QpO1xuXG4gIHJldHVybiAoXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsICYmIG9ic2VydmFibGUgaW4gdmFsdWUpXG4gICAgICA/IHZhbHVlIGFzIE9ic2VydmFibGU8SnNvblZhbHVlIHwgdW5kZWZpbmVkPlxuICAgICAgOiBvYnNlcnZhYmxlT2YodmFsdWUgYXMgSnNvblZhbHVlIHwgdW5kZWZpbmVkKVxuICApLnBpcGUoXG4gICAgY29uY2F0TWFwKCh2YWx1ZTogSnNvblZhbHVlIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb20odmFsdWUpLnBpcGUoXG4gICAgICAgICAgbWVyZ2VNYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfdmlzaXRKc29uUmVjdXJzaXZlKFxuICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICB2aXNpdG9yLFxuICAgICAgICAgICAgICBqb2luSnNvblBvaW50ZXIocHRyLCAnJyArIGkpLFxuICAgICAgICAgICAgICBfZ2V0T2JqZWN0U3ViU2NoZW1hKHNjaGVtYSwgJycgKyBpKSxcbiAgICAgICAgICAgICAgcmVmUmVzb2x2ZXIsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIHJvb3QgfHwgdmFsdWUsXG4gICAgICAgICAgICApLnBpcGUodGFwPEpzb25WYWx1ZT4oeCA9PiB2YWx1ZVtpXSA9IHgpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBpZ25vcmVFbGVtZW50cygpLFxuICAgICAgICAgIGNvbmNhdChvYnNlcnZhYmxlT2YodmFsdWUpKSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmcm9tKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSkucGlwZShcbiAgICAgICAgICBtZXJnZU1hcChrZXkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF92aXNpdEpzb25SZWN1cnNpdmUoXG4gICAgICAgICAgICAgIHZhbHVlW2tleV0sXG4gICAgICAgICAgICAgIHZpc2l0b3IsXG4gICAgICAgICAgICAgIGpvaW5Kc29uUG9pbnRlcihwdHIsIGtleSksXG4gICAgICAgICAgICAgIF9nZXRPYmplY3RTdWJTY2hlbWEoc2NoZW1hLCBrZXkpLFxuICAgICAgICAgICAgICByZWZSZXNvbHZlcixcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgcm9vdCB8fCB2YWx1ZSxcbiAgICAgICAgICAgICkucGlwZSh0YXA8SnNvblZhbHVlPih4ID0+IHZhbHVlW2tleV0gPSB4KSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgaWdub3JlRWxlbWVudHMoKSxcbiAgICAgICAgICBjb25jYXQob2JzZXJ2YWJsZU9mKHZhbHVlKSksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcbn1cblxuLyoqXG4gKiBWaXNpdCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gYSBKU09OIG9iamVjdCwgYWxsb3dpbmcgdG8gdHJhbnNmb3JtIHRoZW0uIEl0IHN1cHBvcnRzIGNhbGxpbmdcbiAqIHByb3BlcnRpZXMgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseSAodGhyb3VnaCBPYnNlcnZhYmxlcykuXG4gKiBUaGUgb3JpZ2luYWwgb2JqZWN0IGNhbiBiZSBtdXRhdGVkIG9yIHJlcGxhY2VkIGVudGlyZWx5LiBJbiBjYXNlIHdoZXJlIGl0J3MgcmVwbGFjZWQsIHRoZSBuZXdcbiAqIHZhbHVlIGlzIHJldHVybmVkLiBXaGVuIGl0J3MgbXV0YXRlZCB0aG91Z2ggdGhlIG9yaWdpbmFsIG9iamVjdCB3aWxsIGJlIGNoYW5nZWQuXG4gKlxuICogUGxlYXNlIG5vdGUgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhbiBpbmZpbml0ZSBsb29wIGhlcmUgKHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgc3RhY2sgb3ZlcmZsb3cpXG4gKiBpZiB5b3UgcmV0dXJuIDIgb2JqZWN0cyB0aGF0IHJlZmVyZW5jZXMgZWFjaCBvdGhlcnMgKG9yIHRoZSBzYW1lIG9iamVjdCBhbGwgdGhlIHRpbWUpLlxuICpcbiAqIEBwYXJhbSB7SnNvblZhbHVlfSBqc29uIFRoZSBKc29uIHZhbHVlIHRvIHZpc2l0LlxuICogQHBhcmFtIHtKc29uVmlzaXRvcn0gdmlzaXRvciBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgaXRlbXMuXG4gKiBAcGFyYW0ge0pzb25PYmplY3R9IHNjaGVtYSBBIEpTT04gc2NoZW1hIHRvIHBhc3MgdGhyb3VnaCB0byB0aGUgdmlzaXRvciAod2hlcmUgcG9zc2libGUpLlxuICogQHBhcmFtIHJlZlJlc29sdmVyIGEgZnVuY3Rpb24gdG8gcmVzb2x2ZSByZWZlcmVuY2VzIGluIHRoZSBzY2hlbWEuXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTwgfCB1bmRlZmluZWQ+fSBUaGUgb2JzZXJ2YWJsZSBvZiB0aGUgbmV3IHJvb3QsIGlmIHRoZSByb290IGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdEpzb248Q29udGV4dFQ+KFxuICBqc29uOiBKc29uVmFsdWUsXG4gIHZpc2l0b3I6IEpzb25WaXNpdG9yLFxuICBzY2hlbWE/OiBKc29uT2JqZWN0LFxuICByZWZSZXNvbHZlcj86IFJlZmVyZW5jZVJlc29sdmVyPENvbnRleHRUPixcbiAgY29udGV4dD86IENvbnRleHRULCAgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1hbnlcbik6IE9ic2VydmFibGU8SnNvblZhbHVlIHwgdW5kZWZpbmVkPiB7XG4gIHJldHVybiBfdmlzaXRKc29uUmVjdXJzaXZlKGpzb24sIHZpc2l0b3IsIGJ1aWxkSnNvblBvaW50ZXIoW10pLCBzY2hlbWEsIHJlZlJlc29sdmVyLCBjb250ZXh0KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXRKc29uU2NoZW1hKHNjaGVtYTogSnNvbk9iamVjdCwgdmlzaXRvcjogSnNvblNjaGVtYVZpc2l0b3IpIHtcbiAgY29uc3Qga2V5d29yZHMgPSB7XG4gICAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICAgIGl0ZW1zOiB0cnVlLFxuICAgIGNvbnRhaW5zOiB0cnVlLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gICAgbm90OiB0cnVlLFxuICB9O1xuXG4gIGNvbnN0IHByb3BzS2V5d29yZHMgPSB7XG4gICAgZGVmaW5pdGlvbnM6IHRydWUsXG4gICAgcHJvcGVydGllczogdHJ1ZSxcbiAgICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgICBkZXBlbmRlbmNpZXM6IHRydWUsXG4gIH07XG5cbiAgZnVuY3Rpb24gX3RyYXZlcnNlKFxuICAgIHNjaGVtYTogSnNvbk9iamVjdCB8IEpzb25BcnJheSxcbiAgICBqc29uUHRyOiBKc29uUG9pbnRlcixcbiAgICByb290U2NoZW1hOiBKc29uT2JqZWN0LFxuICAgIHBhcmVudFNjaGVtYT86IEpzb25PYmplY3QgfCBKc29uQXJyYXksXG4gICAga2V5SW5kZXg/OiBzdHJpbmcsXG4gICkge1xuICAgIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICB2aXNpdG9yKHNjaGVtYSwganNvblB0ciwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09ICdpdGVtcycpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIF90cmF2ZXJzZShcbiAgICAgICAgICAgICAgICBzY2hbaV0gYXMgSnNvbkFycmF5LFxuICAgICAgICAgICAgICAgIGpvaW5Kc29uUG9pbnRlcihqc29uUHRyLCBrZXksICcnICsgaSksXG4gICAgICAgICAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgJycgKyBpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHJvcHNLZXl3b3Jkcykge1xuICAgICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKHNjaCkpIHtcbiAgICAgICAgICAgICAgX3RyYXZlcnNlKFxuICAgICAgICAgICAgICAgIHNjaFtwcm9wXSBhcyBKc29uT2JqZWN0LFxuICAgICAgICAgICAgICAgIGpvaW5Kc29uUG9pbnRlcihqc29uUHRyLCBrZXksIHByb3ApLFxuICAgICAgICAgICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBrZXl3b3Jkcykge1xuICAgICAgICAgIF90cmF2ZXJzZShzY2ggYXMgSnNvbk9iamVjdCwgam9pbkpzb25Qb2ludGVyKGpzb25QdHIsIGtleSksIHJvb3RTY2hlbWEsIHNjaGVtYSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF90cmF2ZXJzZShzY2hlbWEsIGJ1aWxkSnNvblBvaW50ZXIoW10pLCBzY2hlbWEpO1xufVxuIl19